<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>golang技巧集锦 | TickTockit</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="[toc] 项目golang-standards/project-layout基础知识go语言的比较运算未归类time.Time获取当前时间time.Now()返回当前时区的time.Time对象time.Now().Unix()可以转化为UTC的time.Time 时间运算 time.Addtime.Now().Add(-time.Minute * 1) 返回一小时之前的time.Timetim">
<meta property="og:type" content="article">
<meta property="og:title" content="golang技巧集锦">
<meta property="og:url" content="http://www.ticktockit.com/2019/08/19/golang01/index.html">
<meta property="og:site_name" content="TickTockit">
<meta property="og:description" content="[toc] 项目golang-standards/project-layout基础知识go语言的比较运算未归类time.Time获取当前时间time.Now()返回当前时区的time.Time对象time.Now().Unix()可以转化为UTC的time.Time 时间运算 time.Addtime.Now().Add(-time.Minute * 1) 返回一小时之前的time.Timetim">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/9d799d25ly1g1uaoiqgjkj20wm0j9wgr.jpg">
<meta property="og:updated_time" content="2019-08-18T16:14:28.760Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="golang技巧集锦">
<meta name="twitter:description" content="[toc] 项目golang-standards/project-layout基础知识go语言的比较运算未归类time.Time获取当前时间time.Now()返回当前时区的time.Time对象time.Now().Unix()可以转化为UTC的time.Time 时间运算 time.Addtime.Now().Add(-time.Minute * 1) 返回一小时之前的time.Timetim">
<meta name="twitter:image" content="http://ww1.sinaimg.cn/large/9d799d25ly1g1uaoiqgjkj20wm0j9wgr.jpg">
  
    <link rel="alternate" href="/atom.xml" title="TickTockit" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">TickTockit</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">专注于python，golang，运维开发</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.ticktockit.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-golang01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/19/golang01/" class="article-date">
  <time datetime="2019-08-18T16:13:19.000Z" itemprop="datePublished">2019-08-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      golang技巧集锦
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h2 id="golang-standards-project-layout"><a href="#golang-standards-project-layout" class="headerlink" title="golang-standards/project-layout"></a><a href="https://github.com/golang-standards/project-layout" target="_blank" rel="noopener">golang-standards/project-layout</a></h2><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="go语言的比较运算"><a href="#go语言的比较运算" class="headerlink" title="go语言的比较运算"></a><a href="https://studygolang.com/articles/11342" target="_blank" rel="noopener">go语言的比较运算</a></h2><h1 id="未归类"><a href="#未归类" class="headerlink" title="未归类"></a>未归类</h1><h2 id="time-Time"><a href="#time-Time" class="headerlink" title="time.Time"></a>time.Time</h2><h3 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h3><p>time.Now()返回当前时区的time.Time对象<br>time.Now().Unix()可以转化为UTC的time.Time</p>
<h3 id="时间运算"><a href="#时间运算" class="headerlink" title="时间运算"></a>时间运算</h3><ol>
<li>time.Add<br>time.Now().Add(-time.Minute * 1) 返回一小时之前的time.Time<br>time.Now().Add(time.Second * 1) 返回一秒后的time.Time</li>
<li>time.Sub<h3 id="格式化时间戳"><a href="#格式化时间戳" class="headerlink" title="格式化时间戳"></a>格式化时间戳</h3>time.ParseInLocation(“2006-01-02 15:04:05”, v.(string), time.Local) 根据当前时区解析字符串为time.Time<br>time.Parse(“2006-01-02 15:04:05”, v.(string))     根据解析字符串为UTC时区的time.Time    <h3 id="time-Time转字符串"><a href="#time-Time转字符串" class="headerlink" title="time.Time转字符串"></a>time.Time转字符串</h3>time.Unix(t.Unix(), 0).Format(“2006-01-02 15:04:05”) t为time.Time类型     <h3 id="struct-time-Time-Field"><a href="#struct-time-Time-Field" class="headerlink" title="struct time.Time Field"></a>struct time.Time Field</h3>自定义格式化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">type JSONTime time.Time</span><br><span class="line"></span><br><span class="line">func (t JSONTime) MarshalJSON() ([]byte, error) &#123;</span><br><span class="line">	//do your serializing here</span><br><span class="line">	//stamp := fmt.Sprintf(&quot;\&quot;%s\&quot;&quot;, time.Time(t).Format(&quot;Mon Jan _2&quot;))</span><br><span class="line">	stamp := fmt.Sprintf(&quot;\&quot;%s\&quot;&quot;, time.Unix(time.Time(t).Unix(), 0).Format(&quot;2006-01-02 15:04:05&quot;))</span><br><span class="line">	return []byte(stamp), nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type RequestParam struct &#123;</span><br><span class="line">	Period        int      `json:&quot;period&quot;`</span><br><span class="line">	StartTime     JSONTime `json:&quot;start_time&quot;`</span><br><span class="line">	EndTime       JSONTime `json:&quot;end_time&quot;`</span><br><span class="line">	Metric        string   `json:&quot;metric&quot;`</span><br><span class="line">	InstanceNames []string `json:&quot;instance_names&quot;`</span><br><span class="line">	Device        string   `json:&quot;device&quot;`</span><br><span class="line">	Region        string   `json:&quot;region&quot;`</span><br><span class="line">	Carrier       string   `json:&quot;carrier&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="定时tick"><a href="#定时tick" class="headerlink" title="定时tick"></a>定时tick</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  &quot;fmt&quot;</span><br><span class="line">  &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main () &#123;</span><br><span class="line">  tick := time.NewTicker(time.Second)</span><br><span class="line">  for range tick.C &#123;</span><br><span class="line">    fmt.Println(&quot;tick tock kit&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="golang-http-服务器的接口梳理"><a href="#golang-http-服务器的接口梳理" class="headerlink" title="golang http 服务器的接口梳理"></a>golang http 服务器的接口梳理</h2><blockquote>
<p><a href="https://www.jianshu.com/p/16210100d43d" target="_blank" rel="noopener">Golang构建HTTP服务（二）— Handler，ServeMux与中间件</a></p>
</blockquote>
<h3 id="Hanlde和HandleFunc以及Handler-HandlerFunc"><a href="#Hanlde和HandleFunc以及Handler-HandlerFunc" class="headerlink" title="Hanlde和HandleFunc以及Handler, HandlerFunc"></a>Hanlde和HandleFunc以及Handler, HandlerFunc</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func Handle(pattern string, handler Handler)</span><br><span class="line">// Handle 函数将pattern和对应的handler注册进DefaultServeMux</span><br><span class="line">func HandleFunc(pattern string, handler func(ResponseWriter, *Request))</span><br><span class="line">// HandleFunc registers the handler function for the given pattern in the DefaultServeMux</span><br><span class="line">// Handler</span><br><span class="line">// </span><br><span class="line">type Handler interface &#123;</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br><span class="line">// HandlerFunc能够将一个普通的处理函数转化为Handler</span><br><span class="line">type HandlerFunc func(ResponseWriter, *Request)</span><br></pre></td></tr></table></figure>

<p>HandleFunc仅接受一个func为参数，相对于简洁些。Handle则需要传入一个带有ServeHTTP的结构体，因此控制逻辑可以灵活些。</p>
<details><summary>Handle的例子</summary>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">    &quot;net/http&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type countHandler struct &#123;</span><br><span class="line">    mu  sync.Mutex // guards n</span><br><span class="line">    n   int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *countHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    h.mu.Lock()</span><br><span class="line">    defer h.mu.Unlock()</span><br><span class="line">    h.n++</span><br><span class="line">    fmt.Fprintf(w, &quot;count is %d\n&quot;, h.n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    http.Handle(&quot;/count&quot;, new(countHandler))</span><br><span class="line">    log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<details><summary>HandleFunc的例子</summary>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">h1 := func(w http.ResponseWriter, _ *http.Request) &#123;</span><br><span class="line">    io.WriteString(w, &quot;Hello from a HandleFunc #1!\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line">h2 := func(w http.ResponseWriter, _ *http.Request) &#123;</span><br><span class="line">    io.WriteString(w, &quot;Hello from a HandleFunc #2!\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.HandleFunc(&quot;/&quot;, h1)</span><br><span class="line">http.HandleFunc(&quot;/endpoint&quot;, h2)</span><br><span class="line"></span><br><span class="line">log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))</span><br></pre></td></tr></table></figure>

</details>   

<h3 id="ListenAndServe"><a href="#ListenAndServe" class="headerlink" title="ListenAndServe"></a>ListenAndServe</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 监听TCP然后调用handler对应的Serve去处理请求。handler默认为nil，则使用DefaultServeMux</span><br><span class="line">func ListenAndServe(addr string, handler Handler) error</span><br></pre></td></tr></table></figure>

<h3 id="ServeMux"><a href="#ServeMux" class="headerlink" title="ServeMux"></a>ServeMux</h3><p>路由调度器，根据请求url调用handler去处理。实现了Handle，HandleFunc方法。<br>ServeMux实现了ServeHTTP因此也是一个Handler接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 新建</span><br><span class="line">func NewServeMux() *ServeMux</span><br><span class="line">// 方法</span><br><span class="line">func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)</span><br><span class="line">func (mux *ServeMux) Handle(pattern string, handler Handler)</span><br><span class="line">func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))</span><br><span class="line">func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)</span><br><span class="line">// </span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.Handle(&quot;/api/&quot;, apiHandler&#123;&#125;)</span><br><span class="line">mux.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">    // The &quot;/&quot; pattern matches everything, so we need to check</span><br><span class="line">    // that we&apos;re at the root here.</span><br><span class="line">    if req.URL.Path != &quot;/&quot; &#123;</span><br><span class="line">        http.NotFound(w, req)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Fprintf(w, &quot;Welcome to the home page!&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Server-类型"><a href="#Server-类型" class="headerlink" title="Server 类型"></a>Server 类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">type Server struct &#123;</span><br><span class="line">    Addr    string  // TCP address to listen on, &quot;:http&quot; if empty</span><br><span class="line">    Handler Handler // handler to invoke, http.DefaultServeMux if nil</span><br><span class="line">    TLSConfig *tls.Config</span><br><span class="line">    ReadTimeout time.Duration</span><br><span class="line">    ReadHeaderTimeout time.Duration</span><br><span class="line">    WriteTimeout time.Duration</span><br><span class="line">    IdleTimeout time.Duration</span><br><span class="line">    MaxHeaderBytes int</span><br><span class="line">    TLSNextProto map[string]func(*Server, *tls.Conn, Handler)</span><br><span class="line">    ConnState func(net.Conn, ConnState)</span><br><span class="line">    ErrorLog *log.Logger</span><br><span class="line">    // contains filtered or unexported fields</span><br><span class="line">&#125;</span><br><span class="line">// 方法</span><br><span class="line">func (srv *Server) Close() error</span><br><span class="line">func (srv *Server) ListenAndServe() error</span><br><span class="line">func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error</span><br><span class="line">func (srv *Server) RegisterOnShutdown(f func())</span><br><span class="line">func (srv *Server) Serve(l net.Listener) error</span><br><span class="line">func (srv *Server) ServeTLS(l net.Listener, certFile, keyFile string) error</span><br><span class="line">func (srv *Server) SetKeepAlivesEnabled(v bool)</span><br><span class="line">func (srv *Server) Shutdown(ctx context.Context) error</span><br></pre></td></tr></table></figure>

<p>可以通过Server类型来改变默认的Server配置，如改变监听端口等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line">    http.HandleFunc(&quot;/&quot;, index)</span><br><span class="line"></span><br><span class="line">    server := &amp;http.Server&#123;</span><br><span class="line">        Addr: &quot;:8000&quot;,</span><br><span class="line">        ReadTimeout: 60 * time.Second,</span><br><span class="line">        WriteTimeout: 60 * time.Second,</span><br><span class="line">    &#125;</span><br><span class="line">    server.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line">// 自定义的serverMux对象也可以传到server对象中。</span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(&quot;/&quot;, index)</span><br><span class="line"></span><br><span class="line">    server := &amp;http.Server&#123;</span><br><span class="line">        Addr: &quot;:8000&quot;,</span><br><span class="line">        ReadTimeout: 60 * time.Second,</span><br><span class="line">        WriteTimeout: 60 * time.Second,</span><br><span class="line">        Handler: mux,</span><br><span class="line">    &#125;</span><br><span class="line">    server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三种迭代方式"><a href="#三种迭代方式" class="headerlink" title="三种迭代方式"></a>三种迭代方式</h2><blockquote>
<p><a href="https://blog.kowalczyk.info/article/1Bkr/3-ways-to-iterate-in-go.html" target="_blank" rel="noopener">3 ways to iterate in Go</a></p>
</blockquote>
<p>有如下三种迭代的写法：</p>
<ul>
<li>回调函数方式迭代</li>
<li>通过Next()方法迭代。参照python 迭代器的概念，自定义Next()方法来迭代</li>
<li>通过channel实现迭代。<details>

</details></li>
</ul>
<p>假设实现迭代从[2, max],打印出偶数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func printEvenNumbers(max int) &#123;</span><br><span class="line">    if max &lt; 0 &#123;</span><br><span class="line">        log.Fatalf(&quot;&apos;max&apos; is %d, should be &gt;= 0&quot;, max)</span><br><span class="line">    &#125;</span><br><span class="line">    for i := 2; i &lt;= max; i += 2 &#123;</span><br><span class="line">        fmt.Printf(&quot;%d\n&quot;, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回调函数的做法"><a href="#回调函数的做法" class="headerlink" title="回调函数的做法"></a>回调函数的做法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 将迭代的数值传递到回调函数</span><br><span class="line">func printEvenNumbers(max int) &#123;</span><br><span class="line">    err := iterateEvenNumbers(max, func(n int) error &#123;</span><br><span class="line">        fmt.Printf(&quot;%d\n&quot;, n)</span><br><span class="line">        return nil</span><br><span class="line">    &#125;)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        log.Fatalf(&quot;error: %s\n&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 实际的迭代的结果，接受一个回调函数，由回调函数处理</span><br><span class="line">func iterateEvenNumbers(max int, cb func(n int) error) error &#123;</span><br><span class="line">    if max &lt; 0 &#123;</span><br><span class="line">        return fmt.Errorf(&quot;&apos;max&apos; is %d, must be &gt;= 0&quot;, max)</span><br><span class="line">    &#125;</span><br><span class="line">    for i := 2; i &lt;= max; i += 2 &#123;</span><br><span class="line">        err := cb(i)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            return err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Next-方法的迭代"><a href="#Next-方法的迭代" class="headerlink" title="Next()方法的迭代"></a>Next()方法的迭代</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Next()方法放在for循环体之后，通过返回布尔值来控制是否迭代完毕</span><br><span class="line">func (i *EvenNumberIterator) Next() bool </span><br><span class="line">// Value()方法返回当次迭代的值</span><br><span class="line">func (i *EvenNumberIterator) Value() int</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// To run:</span><br><span class="line">// go run next.go</span><br><span class="line"></span><br><span class="line">// EvenNumberIterator generates even number</span><br><span class="line">type EvenNumberIterator struct &#123;</span><br><span class="line">	max       int</span><br><span class="line">	currValue int</span><br><span class="line">	err       error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NewEvenNumberIterator creates new number iterator</span><br><span class="line">func NewEvenNumberIterator(max int) *EvenNumberIterator &#123;</span><br><span class="line">	var err error</span><br><span class="line">	if max &lt; 0 &#123;</span><br><span class="line">		err = fmt.Errorf(&quot;&apos;max&apos; is %d, should be &gt;= 0&quot;, max)</span><br><span class="line">	&#125;</span><br><span class="line">	return &amp;EvenNumberIterator&#123;</span><br><span class="line">		max:       max,</span><br><span class="line">		currValue: 0,</span><br><span class="line">		err:       err,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Next advances to next even number. Returns false on end of iteration.</span><br><span class="line">func (i *EvenNumberIterator) Next() bool &#123;</span><br><span class="line">	if i.err != nil &#123;</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line">	i.currValue += 2</span><br><span class="line">	return i.currValue &lt;= i.max</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Value returns current even number</span><br><span class="line">func (i *EvenNumberIterator) Value() int &#123;</span><br><span class="line">	if i.err != nil || i.currValue &gt; i.max &#123;</span><br><span class="line">		panic(&quot;Value is not valid after iterator finished&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	return i.currValue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Err returns iteration error.</span><br><span class="line">func (i *EvenNumberIterator) Err() error &#123;</span><br><span class="line">	return i.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func printEvenNumbers(max int) &#123;</span><br><span class="line">	iter := NewEvenNumberIterator(max)</span><br><span class="line">	for iter.Next() &#123;</span><br><span class="line">		fmt.Printf(&quot;n: %d\n&quot;, iter.Value())</span><br><span class="line">	&#125;</span><br><span class="line">	if iter.Err() != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;error: %s\n&quot;, iter.Err())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Printf(&quot;Even numbers up to 8:\n&quot;)</span><br><span class="line">	printEvenNumbers(8)</span><br><span class="line">	fmt.Printf(&quot;Even numbers up to 9:\n&quot;)</span><br><span class="line">	printEvenNumbers(9)</span><br><span class="line">	fmt.Printf(&quot;Error: even numbers up to -1:\n&quot;)</span><br><span class="line">	printEvenNumbers(-1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="chan方式迭代"><a href="#chan方式迭代" class="headerlink" title="chan方式迭代"></a>chan方式迭代</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个返回channel的函数</span><br><span class="line">func generateEvenNumbers(max int) chan IntWithError</span><br><span class="line">// IntWithError struct</span><br><span class="line">type IntWithError struct &#123;</span><br><span class="line">    Int int</span><br><span class="line">    Err error</span><br><span class="line">&#125;</span><br><span class="line">// 调用方法，range方法可以接chan遍历的特性</span><br><span class="line">func printEvenNumbers(max int) &#123;</span><br><span class="line">    for val := range generateEvenNumbers(max) &#123;</span><br><span class="line">        if val.Err != nil &#123;</span><br><span class="line">            log.Fatalf(&quot;Error: %s\n&quot;, val.Err)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(&quot;%d\n&quot;, val.Int)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 完整generateEvenNumbers</span><br><span class="line">func generateEvenNumbers(max int) chan IntWithError &#123;</span><br><span class="line">    ch := make(chan IntWithError)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        defer close(ch)</span><br><span class="line">        if max &lt; 0 &#123;</span><br><span class="line">            ch &lt;- IntWithError&#123;</span><br><span class="line">                Err: fmt.Errorf(&quot;&apos;max&apos; is %d and should be &gt;= 0&quot;, max),</span><br><span class="line">            &#125;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for i := 2; i &lt;= max; i += 2 &#123;</span><br><span class="line">            ch &lt;- IntWithError&#123;</span><br><span class="line">                Int: i,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    return ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// To run:</span><br><span class="line">// go run channel.go</span><br><span class="line"></span><br><span class="line">// IntWithError combines an integer value and an error</span><br><span class="line">type IntWithError struct &#123;</span><br><span class="line">	Int int</span><br><span class="line">	Err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func generateEvenNumbers(max int) chan IntWithError &#123;</span><br><span class="line">	ch := make(chan IntWithError)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		defer close(ch)</span><br><span class="line">		if max &lt; 0 &#123;</span><br><span class="line">			ch &lt;- IntWithError&#123;</span><br><span class="line">				Err: fmt.Errorf(&quot;&apos;max&apos; is %d and should be &gt;= 0&quot;, max),</span><br><span class="line">			&#125;</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for i := 2; i &lt;= max; i += 2 &#123;</span><br><span class="line">			ch &lt;- IntWithError&#123;</span><br><span class="line">				Int: i,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	return ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func printEvenNumbers(max int) &#123;</span><br><span class="line">	for val := range generateEvenNumbers(max) &#123;</span><br><span class="line">		if val.Err != nil &#123;</span><br><span class="line">			log.Fatalf(&quot;Error: %s\n&quot;, val.Err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(&quot;%d\n&quot;, val.Int)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Printf(&quot;Even numbers up to 8:\n&quot;)</span><br><span class="line">	printEvenNumbers(8)</span><br><span class="line">	fmt.Printf(&quot;Even numbers up to 9:\n&quot;)</span><br><span class="line">	printEvenNumbers(9)</span><br><span class="line">	fmt.Printf(&quot;Error: even numbers up to -1:\n&quot;)</span><br><span class="line">	printEvenNumbers(-1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过context实现cancel停止迭代功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;context&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// To run:</span><br><span class="line">// go run channel-cancellable.go</span><br><span class="line"></span><br><span class="line">// IntWithError combines an integer value and an error</span><br><span class="line">type IntWithError struct &#123;</span><br><span class="line">	Int int</span><br><span class="line">	Err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func generateEvenNumbers(ctx context.Context, max int) chan IntWithError &#123;</span><br><span class="line">	ch := make(chan IntWithError)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		defer close(ch)</span><br><span class="line">		if max &lt; 0 &#123;</span><br><span class="line">			ch &lt;- IntWithError&#123;</span><br><span class="line">				Err: fmt.Errorf(&quot;&apos;max&apos; is %d and should be &gt;= 0&quot;, max),</span><br><span class="line">			&#125;</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for i := 2; i &lt;= max; i += 2 &#123;</span><br><span class="line">			if ctx != nil &#123;</span><br><span class="line">				// if context was cancelled, we stop early</span><br><span class="line">				select &#123;</span><br><span class="line">				case &lt;-ctx.Done():</span><br><span class="line">					return</span><br><span class="line">				default:</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			ch &lt;- IntWithError&#123;</span><br><span class="line">				Int: i,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	return ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func printEvenNumbersCancellable(max int, stopAt int) &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	defer cancel()</span><br><span class="line">	ch := generateEvenNumbers(ctx, max)</span><br><span class="line">	for val := range ch &#123;</span><br><span class="line">		if val.Err != nil &#123;</span><br><span class="line">			log.Fatalf(&quot;Error: %s\n&quot;, val.Err)</span><br><span class="line">		&#125;</span><br><span class="line">		if val.Int &gt; stopAt &#123;</span><br><span class="line">			cancel()</span><br><span class="line">			// notice we keep going in order to drain the channel</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">		// process the value</span><br><span class="line">		fmt.Printf(&quot;%d\n&quot;, val.Int)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Printf(&quot;Even numbers up to 20, cancel at 8:\n&quot;)</span><br><span class="line">	printEvenNumbersCancellable(20, 8)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>回调方式实现起来最简单但是语法很别扭</li>
<li>Next()方法实现最困难，但是对调用方很友好，标准库里运用了这种复杂写法</li>
<li>channel的实现很好，对系统资源的消耗最昂贵，channel应该与goroutine搭配使用，否则尽量不用


</li>
</ol>
<h2 id="捕获Ctrl-C中断-优雅的退出程序"><a href="#捕获Ctrl-C中断-优雅的退出程序" class="headerlink" title="捕获Ctrl + C中断 优雅的退出程序"></a>捕获Ctrl + C中断 优雅的退出程序</h2><blockquote>
<p><a href="https://guzalexander.com/2017/05/31/gracefully-exit-server-in-go.html" target="_blank" rel="noopener">Gracefully terminate a program in Go</a></p>
<ul>
<li><a href="http://docs.studygolang.com/pkg/os/signal/" target="_blank" rel="noopener">os/signal</a> 来捕获系统中断等信号</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Notify方法将signal发送到channel，</span><br><span class="line">func Notify(c chan&lt;- os.Signal, sig ...os.Signal)</span><br><span class="line">// 初始化一个接受os.Signal的通道</span><br><span class="line">c := make(chan os.Signal)</span><br><span class="line">// 调用Notify方法，绑定signal到channel，一旦有信号到达，signal会发送到channel中</span><br><span class="line">signal.Notify(c, os.Interrupt)</span><br></pre></td></tr></table></figure>

<details><summary>完整代码</summary>

<ol>
<li>代码实现在命令行每隔200ms打印字符”#”，使用time.Ticker实现每隔2s打印完整一次     </li>
<li>task有一个close的channel，用来接受停止信号</li>
<li>实例化一个os.Signal来接受诸如ctrl+c的停止信号</li>
<li>使用sync.WaitGroup来组织多个goroutine的调度</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;os&quot;</span><br><span class="line">	&quot;os/signal&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Task struct &#123;</span><br><span class="line">	closed chan struct&#123;&#125;</span><br><span class="line">	wg     sync.WaitGroup</span><br><span class="line">	ticker *time.Ticker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t *Task) Run() &#123;</span><br><span class="line">	for &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">		case &lt;-t.closed:</span><br><span class="line">			return</span><br><span class="line">		case &lt;-t.ticker.C:</span><br><span class="line">			handle()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t *Task) Stop() &#123;</span><br><span class="line">	close(t.closed)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func handle() &#123;</span><br><span class="line">	for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">		fmt.Print(&quot;#&quot;)</span><br><span class="line">		time.Sleep(time.Millisecond * 200)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	task := &amp;Task&#123;</span><br><span class="line">		closed: make(chan struct&#123;&#125;),</span><br><span class="line">		ticker: time.NewTicker(time.Second * 2),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c := make(chan os.Signal)</span><br><span class="line">	signal.Notify(c, os.Interrupt)</span><br><span class="line"></span><br><span class="line">	task.wg.Add(1)</span><br><span class="line">	go func() &#123; defer task.wg.Done(); task.Run() &#125;()</span><br><span class="line"></span><br><span class="line">	select &#123;</span><br><span class="line">	case sig := &lt;-c:</span><br><span class="line">		fmt.Printf(&quot;Got %s signal. Aborting...\n&quot;, sig)</span><br><span class="line">		task.Stop()</span><br><span class="line">	&#125;</span><br><span class="line">  task.wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul>
<li><p>map的key不能是slice, map, function等不可比较类型，但可以是bool，数字，string， 指针，channel和只包含这几种类型的interface types， structs，arrays</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">  mymap := make(map[interface&#123;&#125;]interface&#123;&#125;)</span><br><span class="line">  mymap[true] = true</span><br><span class="line">  // f := func() &#123;&#125;</span><br><span class="line">  // mymap[f] = 1 报错 panic: runtime error: hash of unhashable type func()</span><br><span class="line">  stu := struct &#123;</span><br><span class="line">    first string</span><br><span class="line">  &#125;&#123;&quot;test&quot;&#125;</span><br><span class="line">  mymap[stu] = 2</span><br><span class="line">  </span><br><span class="line">  // slc := []int&#123;1, 2, 3&#125;</span><br><span class="line">  // mymap[slc] = 4 panic: runtime error: hash of unhashable type []int</span><br><span class="line">  </span><br><span class="line">  // mymap[mymap] = 3</span><br><span class="line"></span><br><span class="line">  fmt.Printf(&quot;%+v\n&quot;, mymap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>零值为nil，需要用new，make初始化</p>
</li>
<li><p>查询一个不存在的键不会报错，会返回对应的零值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">m := make(map[string]int)</span><br><span class="line">fmt.Println(m[&quot;apple&quot;) // 0</span><br><span class="line">// 当apple为零值时，第二个返回值用来判断apple键是否在map中。</span><br><span class="line">if apple, ok := m2[&quot;apple&quot;]; ok &#123;</span><br><span class="line">fmt.Println(apple)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指针map</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Param map[string]interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">type Show struct &#123;</span><br><span class="line">    *Param</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    s := Show&#123;&amp;Param&#123;&quot;RMB&quot;: 3&#125;&#125;</span><br><span class="line">    fmt.Printf(&quot;%+v&quot;, s)</span><br><span class="line">    smap := s.Param</span><br><span class="line">    (*smap)[&quot;RMB&quot;] = 1</span><br><span class="line">    fmt.Printf(&quot;%+v&quot;, *s.Param)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="切片-slice"><a href="#切片-slice" class="headerlink" title="切片 slice"></a>切片 slice</h2><ul>
<li>切片的零值是nil，需要用make，new 初始化</li>
<li>切片去除某个元素<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Remove item at index 1 from the slice</span><br><span class="line">c = append(c[:1], c[2:]...)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h2><ul>
<li>runtime.Gosched()<br>暂时挂起当前goroutine，让其他goroutine先执行。</li>
<li>runtime.Goexit()<br>调用此函数的goroutine会别终止</li>
<li>runtime.GOMAXPROCS(numcpu int)<br>设置当前并行的CPU核数，会返回之前的值，会停止当前的程序，因此在程序最开始处调用</li>
</ul>
<h2 id="Channel使用的技巧和注意实现"><a href="#Channel使用的技巧和注意实现" class="headerlink" title="Channel使用的技巧和注意实现"></a>Channel使用的技巧和注意实现</h2><blockquote>
<p><a href="http://udhos.github.io/golang-concurrency-tricks/" target="_blank" rel="noopener">Golang Concurrency Tricks</a></p>
<ul>
<li>注意<strong>nil channel</strong>，send，receive一个nil channel会blocking，close nil channel will panic</li>
<li>注意close channel，close一个nil channel会引起panic，close一个已经close的channel会引起panic，向一个closed的channel发送也会引起panic</li>
<li>不要在receiver goroutine中关闭close channel，这会导致send goroutine向closed channel发送数据时panic</li>
<li>在多个send goroutine时，其中一个send goroutine关闭channel后，其他send goroutine向一个closed channel发送数据会引起panic</li>
<li>没必要主动close channel，因为当没有goroutine指向channel时，channel会被垃圾回收</li>
<li>在select中使用</li>
<li>两个goroutine双向交流应该用两个单向channel，因此通道两侧都可以使用close channel来终止信号。</li>
<li>sender goroutine会一直blocking，当没有其他goroutine从channel取值。<br>技巧：</li>
<li>一个gorotine来接受一段数据是一个好的设计</li>
<li>使用<a href="https://golang.org/pkg/runtime/#Goexit" target="_blank" rel="noopener">runtime.Goexit()</a>来终止调用它的goroutine</li>
<li>单向channel不能close </li>
</ul>
</blockquote>
<h2 id="json解析奇巧淫技"><a href="#json解析奇巧淫技" class="headerlink" title="json解析奇巧淫技"></a>json解析奇巧淫技</h2><blockquote>
<p><a href="https://gocn.io/article/363" target="_blank" rel="noopener">Golang 中使用 JSON 的小技巧</a></p>
</blockquote>
<h2 id="interface-内部结构"><a href="#interface-内部结构" class="headerlink" title="interface 内部结构"></a>interface 内部结构</h2><p>go中的接口分为两种，一种是空接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var in interface&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>另一种(定义了方法，就不属于空接口了)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type People interface &#123;</span><br><span class="line">    Show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>

<p>它们的底层结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">type eface struct &#123;      //空接口</span><br><span class="line">    _type *_type         //类型信息</span><br><span class="line">    data  unsafe.Pointer //指向数据的指针(go语言中特殊的指针类型unsafe.Pointer类似于c语言中的void*)</span><br><span class="line">&#125;</span><br><span class="line">type iface struct &#123;      //带有方法的接口</span><br><span class="line">    tab  *itab           //存储type信息还有结构实现方法的集合</span><br><span class="line">    data unsafe.Pointer  //指向数据的指针(go语言中特殊的指针类型unsafe.Pointer类似于c语言中的void*)</span><br><span class="line">&#125;</span><br><span class="line">type _type struct &#123;</span><br><span class="line">    size       uintptr  //类型大小</span><br><span class="line">    ptrdata    uintptr  //前缀持有所有指针的内存大小</span><br><span class="line">    hash       uint32   //数据hash值</span><br><span class="line">    tflag      tflag</span><br><span class="line">    align      uint8    //对齐</span><br><span class="line">    fieldalign uint8    //嵌入结构体时的对齐</span><br><span class="line">    kind       uint8    //kind 有些枚举值kind等于0是无效的</span><br><span class="line">    alg        *typeAlg //函数指针数组，类型实现的所有方法</span><br><span class="line">    gcdata    *byte</span><br><span class="line">    str       nameOff</span><br><span class="line">    ptrToThis typeOff</span><br><span class="line">&#125;</span><br><span class="line">type itab struct &#123;</span><br><span class="line">    inter  *interfacetype  //接口类型</span><br><span class="line">    _type  *_type          //结构类型</span><br><span class="line">    link   *itab</span><br><span class="line">    bad    int32</span><br><span class="line">    inhash int32</span><br><span class="line">    fun    [1]uintptr      //可变大小 方法集合</span><br></pre></td></tr></table></figure>

<p>可以看出iface比eface中间多了一层itab结构。itab存储_type信息和[]fun方法集，从上面的结构我们就可得出，因为data指向了nil并不代表interface是nil,所以返回值并不为空，这里的fun(方法集)定义了接口的接收规则，在编译的过程中需要验证是否实现接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type People interface &#123;</span><br><span class="line">	Show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Student struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (stu *Student) Show() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func live() People &#123;</span><br><span class="line">	var stu *Student</span><br><span class="line">	return stu</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	if live() == nil &#123;</span><br><span class="line">		fmt.Println(&quot;AAAAAAA&quot;)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		fmt.Println(&quot;BBBBBBB&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h2 id="结构体的比较"><a href="#结构体的比较" class="headerlink" title="结构体的比较(==)"></a>结构体的比较(==)</h2><ul>
<li>只有相同类型的结构体才可以比较，结构体是否相同与属性和属性的顺序有关</li>
<li>当结构体中有不可比较的类型时，如map，slice，不能用==比较，</li>
<li>但可以使用reflect.DeepEqual进行比较<details>

</details></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	sn1 := struct &#123;</span><br><span class="line">		age  int</span><br><span class="line">		name string</span><br><span class="line">	&#125;&#123;age: 11, name: &quot;qq&quot;&#125;</span><br><span class="line">	sn2 := struct &#123;</span><br><span class="line">		age  int</span><br><span class="line">		name string</span><br><span class="line">	&#125;&#123;age: 11, name: &quot;qq&quot;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	sm1 := struct &#123;</span><br><span class="line">		age int</span><br><span class="line">		m   map[string]string</span><br><span class="line">	&#125;&#123;age: 11, m: map[string]string&#123;&quot;a&quot;: &quot;1&quot;&#125;&#125;</span><br><span class="line">	sm2 := struct &#123;</span><br><span class="line">		age int</span><br><span class="line">		m   map[string]string</span><br><span class="line">	&#125;&#123;age: 11, m: map[string]string&#123;&quot;a&quot;: &quot;1&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line">  if reflect.DeepEqual(sn1, sn2) &#123;</span><br><span class="line">    fmt.Println(&quot;sn1 ==sn2&quot;)</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    fmt.Println(&quot;sn1 !=sn2&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  if reflect.DeepEqual(sm1, sm2) &#123;</span><br><span class="line">    fmt.Println(&quot;sm1 ==sm2&quot;)</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    fmt.Println(&quot;sm1 !=sm2&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  if reflect.DeepEqual(sn1, sm1) &#123;</span><br><span class="line">    fmt.Println(&quot;sn1 ==sm1&quot;)</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    fmt.Println(&quot;sn1 !=sm1&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="golang-error-错误处理的手段"><a href="#golang-error-错误处理的手段" class="headerlink" title="golang error 错误处理的手段"></a>golang error 错误处理的手段</h2><ul>
<li>使用pkg/errors, (go2.x 有error处理新提案，该库进入维护阶段)<br><a href="https://godoc.org/github.com/pkg/errors" target="_blank" rel="noopener">go doc</a><br><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">博客介绍</a></li>
<li><a href="https://mijailovic.net/2017/05/09/error-handling-patterns-in-go/" target="_blank" rel="noopener">Error handling patterns in Go</a></li>
</ul>
<h2 id="Go-使用默认参数的技巧"><a href="#Go-使用默认参数的技巧" class="headerlink" title="Go 使用默认参数的技巧"></a>Go 使用默认参数的技巧</h2><blockquote>
<p><a href="https://halls-of-valhalla.org/beta/articles/functional-options-pattern-in-go,54/" target="_blank" rel="noopener">Functional Options Pattern in Go</a>    </p>
</blockquote>
<p>golang中没有函数默认参数的设计，因此需要些特别的技巧来实现。<br>假如我们需要订购一批电脑，其中电脑配置cpu，gpu，内存支持自定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Computer interface &#123;</span><br><span class="line">  PowerOn() error</span><br><span class="line">  PowerOff() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type computer struct &#123;</span><br><span class="line">  name string</span><br><span class="line">  cpu string</span><br><span class="line">  gpu string</span><br><span class="line">  memorySize int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义自定义参数配置，创建一个默认的电脑配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type pcConfigure struct &#123;</span><br><span class="line">  cpu string</span><br><span class="line">  gpu string</span><br><span class="line">  memorySize int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var DefaultPConfigure = pcConfigure &#123;</span><br><span class="line">  &quot;i3 2120&quot;,</span><br><span class="line">  &quot;GTX 660&quot;,</span><br><span class="line">  12&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个闭包函数，接受自定义的配置参数，返回一个自定义的参数配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">type newPcConfigure func(*pcConfigure)</span><br><span class="line"></span><br><span class="line">func newCpuConfigure(cpu string) newPcConfigure &#123;</span><br><span class="line">  return func(o *pcConfigure) &#123;</span><br><span class="line">    o.cpu = cpu</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func newGpuConfigure(gpu string) newPcConfigure &#123;</span><br><span class="line">  return func(o *pcConfigure) &#123;</span><br><span class="line">    o.gpu = gpu</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func newMemorySizeConfigure(memorySize int) newPcConfigure &#123;</span><br><span class="line">  return func(o *pcConfigure) &#123;</span><br><span class="line">    o.memorySize = memorySize</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一步，定义一个构造coputer的函数，接受上面的闭包函数为参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func newComputer(name string, opts ...newPcConfigure) *computer &#123;</span><br><span class="line">  pcConfigure := DefaultPConfigure</span><br><span class="line">  for _, o := range opts &#123;</span><br><span class="line">    o(&amp;pcConfigure)</span><br><span class="line">  &#125;</span><br><span class="line">  return &amp;computer &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    cpu: pcConfigure.cpu,</span><br><span class="line">    gpu: pcConfigure.gpu,</span><br><span class="line">    memorySize: pcConfigure.memorySize&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"> </span><br><span class="line">import (</span><br><span class="line">  &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">type pcConfigure struct &#123;</span><br><span class="line">  cpu string</span><br><span class="line">  gpu string</span><br><span class="line">  memorySize int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var DefaultPConfigure = pcConfigure &#123;</span><br><span class="line">  &quot;i3 2120&quot;,</span><br><span class="line">  &quot;GTX 660&quot;,</span><br><span class="line">  12&#125;</span><br><span class="line"></span><br><span class="line">type newPcConfigure func(*pcConfigure)</span><br><span class="line"></span><br><span class="line">func newCpuConfigure(cpu string) newPcConfigure &#123;</span><br><span class="line">  return func(o *pcConfigure) &#123;</span><br><span class="line">    o.cpu = cpu</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func newGpuConfigure(gpu string) newPcConfigure &#123;</span><br><span class="line">  return func(o *pcConfigure) &#123;</span><br><span class="line">    o.gpu = gpu</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func newMemorySizeConfigure(memorySize int) newPcConfigure &#123;</span><br><span class="line">  return func(o *pcConfigure) &#123;</span><br><span class="line">    o.memorySize = memorySize</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Computer interface &#123;</span><br><span class="line">  PowerOn() error</span><br><span class="line">  PowerOff() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type computer struct &#123;</span><br><span class="line">  name string</span><br><span class="line">  cpu string</span><br><span class="line">  gpu string</span><br><span class="line">  memorySize int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func newComputer(name string, opts ...newPcConfigure) *computer &#123;</span><br><span class="line">  pcConfigure := DefaultPConfigure</span><br><span class="line">  for _, o := range opts &#123;</span><br><span class="line">    o(&amp;pcConfigure)</span><br><span class="line">  &#125;</span><br><span class="line">  return &amp;computer &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    cpu: pcConfigure.cpu,</span><br><span class="line">    gpu: pcConfigure.gpu,</span><br><span class="line">    memorySize: pcConfigure.memorySize&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (c *computer) PowerOn() (err error) &#123;</span><br><span class="line">  return </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *computer) PowerOff() (err error) &#123;</span><br><span class="line">  return </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main () &#123;</span><br><span class="line">  pc1 := newComputer(&quot;pc1&quot;)</span><br><span class="line">  fmt.Println(pc1)</span><br><span class="line">  pc2 := newComputer(&quot;pc2&quot;, newCpuConfigure(&quot;i7 8700k&quot;), newGpuConfigure(&quot;RTX 2080ti&quot;))</span><br><span class="line">  fmt.Println(pc2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h2 id="http-net"><a href="#http-net" class="headerlink" title="http/net"></a>http/net</h2><h3 id="Things-to-know-about-HTTP-in-Go"><a href="#Things-to-know-about-HTTP-in-Go" class="headerlink" title="Things to know about HTTP in Go"></a><a href="https://scene-si.org/2017/09/27/things-to-know-about-http-in-go/" target="_blank" rel="noopener">Things to know about HTTP in Go</a></h3><ul>
<li>net/http/httputil, 使用httputil.DumpRequest(r, true)来dump the request body</li>
</ul>
<h2 id="fmt-漫谈"><a href="#fmt-漫谈" class="headerlink" title="fmt 漫谈"></a>fmt 漫谈</h2><blockquote>
<p><a href="https://medium.com/go-walkthrough/go-walkthrough-fmt-55a14bbbfc53" target="_blank" rel="noopener">Go Walkthrough: fmt</a></p>
</blockquote>
<details>

<h3 id="fmt常用的格式化字符串"><a href="#fmt常用的格式化字符串" class="headerlink" title="fmt常用的格式化字符串"></a>fmt常用的格式化字符串</h3><ul>
<li>%v 是个通用的占位符。它会自动将变量转换为默认格式的字符串，这在打印字符串或数字等原语时非常有用，而且不需要特定的选项</li>
<li>%#v 根据go语法打印。尤其在打印struct和切片时特别直观</li>
</ul>
<details> <summary>例子</summary>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">  &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">//1</span><br><span class="line">var brand = &quot;ALIENWARE&quot;</span><br><span class="line">type computer struct &#123;</span><br><span class="line">  name string</span><br><span class="line">  price float32</span><br><span class="line">  config []string</span><br><span class="line">  brand *string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  myComputer := computer&#123;&quot;tktk&quot;, 18000.00, []string&#123;&quot;i7 9700k&quot;, &quot;RTX 2080Ti&quot;, &quot;DDR4 32G&quot;&#125;, &amp;brand&#125;</span><br><span class="line">  fmt.Printf(&quot;my computer is: \n%#v\n&quot;, myComputer)</span><br><span class="line">    fmt.Printf(&quot;my computer is: \n%v\n&quot;, myComputer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go version go1.12 linux/amd64</span><br><span class="line">my computer is:</span><br><span class="line">main.computer&#123;name:&quot;tktk&quot;, price:18000, config:[]string&#123;&quot;i7 9700k&quot;, &quot;RTX 2080Ti&quot;, &quot;DDR4 32G&quot;&#125;, brand:(*string)(0x5531b0)&#125;</span><br><span class="line">my computer is:</span><br><span class="line">&#123;tktk 18000 [i7 9700k RTX 2080Ti DDR4 32G] 0x5531b0&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<ul>
<li><p>%T 打印变量的类型</p>
</li>
<li><p>%d 打印10进制整数</p>
</li>
<li><p>%x和%X 打印16进制整数</p>
</li>
<li><p>%f 打印浮点数，可以通过%8.2f，%-8.2f，%08.2f,% f等来控制打印字符串的空格</p>
</li>
<li><p>%q 能打印加引号的字符串。当您的数据可能有不可见字符(如空字符串)时，这是有用的，因为引用的字符串将它们打印为转义序列。</p>
</li>
<li><p>%p 打印变量的指针地址。当您正在调试代码并且希望检查不同的指针变量是否引用相同的数据时，这个方法非常有用。</p>
<h4 id="fmt-Printing"><a href="#fmt-Printing" class="headerlink" title="fmt Printing"></a>fmt Printing</h4><h5 id="FMT包的主要用途是格式化字符串。这些格式化函数按其输出类型-STDOUT、io-Writer和String进行分组。"><a href="#FMT包的主要用途是格式化字符串。这些格式化函数按其输出类型-STDOUT、io-Writer和String进行分组。" class="headerlink" title="FMT包的主要用途是格式化字符串。这些格式化函数按其输出类型-STDOUT、io.Writer和String进行分组。"></a>FMT包的主要用途是格式化字符串。这些格式化函数按其输出类型-STDOUT、io.Writer和String进行分组。</h5></li>
<li><p>打印到stdout</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 按照默认格式打印一系列变量</span><br><span class="line">func Print(a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">// 相比Print，在变量之间插入了空格，并最后添加上换行符</span><br><span class="line">func Println(a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">// 根据自定义格式化字符串，能打印不同格式的输出</span><br><span class="line">func Printf(format string, a ...interface&#123;&#125;) (n int, err error)</span><br></pre></td></tr></table></figure>
</li>
<li><p>打印到io.Writer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Fprint(w io.Writer, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">func Fprintf(w io.Writer, format string, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">func Fprintln(w io.Writer, a ...interface&#123;&#125;) (n int, err error)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Fprint是更通用的形式，print仅仅是Fprint(os.Stdout, “Hello World!”)的包装</p>
<ul>
<li>格式为字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Sprint(a ...interface&#123;&#125;) string</span><br><span class="line">func Sprintf(format string, a ...interface&#123;&#125;) string</span><br><span class="line">func Sprintln(a ...interface&#123;&#125;) string</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>当大量采用Sprint产生字符串，会产生瓶颈问题。</p>
<ul>
<li>Errorf() <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Errorf(format string, a ...interface&#123;&#125;) error &#123;</span><br><span class="line">	return errors.New(Sprintf(format, a...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Scanning"><a href="#Scanning" class="headerlink" title="Scanning"></a>Scanning</h4><p>fmt包也有从stdin，io.Reader, string读取并格式化的api。</p>
<ul>
<li><p>从stdin读取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Scan(a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">func Scanf(format string, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">func Scanln(a ...interface&#123;&#125;) (n int, err error)</span><br></pre></td></tr></table></figure>
</li>
<li><p>从io.Reader读取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Fscan(r io.Reader, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">func Fscanf(r io.Reader, format string, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">func Fscanln(r io.Reader, a ...interface&#123;&#125;) (n int, err error)</span><br></pre></td></tr></table></figure>
</li>
<li><p>从string读取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Sscan(str string, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">func Sscanf(str string, format string, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">func Sscanln(str string, a ...interface&#123;&#125;) (n int, err error)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<details> <summary>例子</summary>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var name string</span><br><span class="line">var age int</span><br><span class="line">if _, err := fmt.Scan(&amp;name, &amp;age); err != nil &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;Your name is: %s\n&quot;, name)</span><br><span class="line">fmt.Printf(&quot;Your age is: %d\n&quot;, age)</span><br></pre></td></tr></table></figure>

<p>执行交互</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">Jane 25</span><br><span class="line">Your name is: Jane</span><br><span class="line">Your age is: 25</span><br></pre></td></tr></table></figure>

<p>总之，如果从命令行读取并解析到指定的interface，如例子中的name，age，我们有更好用的flag包可以使用</p>
</details>


</details>

<h2 id="IO-Streaming"><a href="#IO-Streaming" class="headerlink" title="IO Streaming"></a>IO Streaming</h2><blockquote>
<p><a href="https://medium.com/learning-the-go-programming-language/streaming-io-in-go-d93507931185" target="_blank" rel="noopener">Streaming IO in Go</a>，引用此文，略有修改<br><a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter01/01.1.html" target="_blank" rel="noopener">io — 基本的 IO 接口</a></p>
</blockquote>
<details>

<h3 id="io-Reader和io-Writer"><a href="#io-Reader和io-Writer" class="headerlink" title="io.Reader和io.Writer"></a>io.Reader和io.Writer</h3><p>io.Reader接口定义了从传输缓存读取数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Reader interface &#123;</span><br><span class="line">    Read(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Read方法接受一个[]byte作为读取数据后的接收者，返回读取的字节数n和错误err，当读尽缓存内容时，err为io.EOF。<br>Read方法的读取机制</p>
<ol>
<li>尽可能读取len(p)字节到p</li>
<li>调用Read()后，n可能比len(p)小</li>
<li>如果出现错误，read()仍可能返回缓冲区p中的n个字节。例如，读取突然关闭的TCP套接字。根据您的使用，您可以选择将字节保持在p中或重试。</li>
<li>当Read()读尽数据后，可能返回非零的n和err=io.EOF。甚至出现返回非零n和err=nil的情况，但是接下来的Read()方法调用一定返回n=0, err=io.EOF</li>
<li>当n=0，err=nil时，并不意味着读取数据完毕，接下来的Read()可能返回更多的数据。</li>
</ol>
<p>综上，实现Read()方法还是比较棘手的，幸好标准库有好多实现了io.Reader的接口。</p>
<h3 id="strings-NewReader"><a href="#strings-NewReader" class="headerlink" title="strings.NewReader"></a>strings.NewReader</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// NewReader returns a new Reader reading from s. </span><br><span class="line">// It is similar to bytes.NewBufferString </span><br><span class="line">// but more efficient and read-only.</span><br><span class="line">func NewReader(s string) *Reader</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	reader := strings.NewReader(&quot;Clear is better than clever&quot;)</span><br><span class="line">	p := make([]byte, 4)</span><br><span class="line">	</span><br><span class="line">	for &#123;</span><br><span class="line">		n, err := reader.Read(p)</span><br><span class="line">		if err != nil&#123;</span><br><span class="line">		    if err == io.EOF &#123;</span><br><span class="line">			fmt.Println(string(p[:n])) //should handle any remainding bytes.</span><br><span class="line">			break</span><br><span class="line">		    &#125;</span><br><span class="line">		    fmt.Println(err)</span><br><span class="line">		    os.Exit(1)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(string(p[:n]))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义io-Reader"><a href="#自定义io-Reader" class="headerlink" title="自定义io.Reader"></a>自定义io.Reader</h3><p>实现Read()方法，去除非字母</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">type alphaReader struct &#123;</span><br><span class="line">	src string</span><br><span class="line">	cur int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func newAlphaReader(src string) *alphaReader &#123;</span><br><span class="line">	return &amp;alphaReader&#123;src: src&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func alpha(r byte) byte &#123;</span><br><span class="line">	if (r &gt;= &apos;A&apos; &amp;&amp; r &lt;= &apos;Z&apos;) || (r &gt;= &apos;a&apos; &amp;&amp; r &lt;= &apos;z&apos;) &#123;</span><br><span class="line">		return r</span><br><span class="line">	&#125;</span><br><span class="line">	return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *alphaReader) Read(p []byte) (int, error) &#123;</span><br><span class="line">	if a.cur &gt;= len(a.src) &#123;</span><br><span class="line">		return 0, io.EOF</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	x := len(a.src) - a.cur</span><br><span class="line">	n, bound := 0, 0</span><br><span class="line">	if x &gt;= len(p) &#123;</span><br><span class="line">		bound = len(p)</span><br><span class="line">	&#125; else if x &lt;= len(p) &#123;</span><br><span class="line">		bound = x</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	buf := make([]byte, bound)</span><br><span class="line">	for n &lt; bound &#123;</span><br><span class="line">		if char := alpha(a.src[a.cur]); char != 0 &#123;</span><br><span class="line">			buf[n] = char</span><br><span class="line">		&#125;</span><br><span class="line">		n++</span><br><span class="line">		a.cur++</span><br><span class="line">	&#125;</span><br><span class="line">	copy(p, buf) // 使用copy方法，保证切片每次读取指定大小的内容</span><br><span class="line">	return n, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	reader := newAlphaReader(&quot;Hello! It&apos;s 9am, where is the sun?&quot;)</span><br><span class="line">	p := make([]byte, 4)</span><br><span class="line">	for &#123;</span><br><span class="line">		n, err := reader.Read(p)</span><br><span class="line">		if err == io.EOF &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Print(string(p[:n]))</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>借助标准库的io.Reader实现来简化代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">type alphaReader struct &#123;</span><br><span class="line">	reader io.Reader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func newAlphaReader(reader io.Reader) *alphaReader &#123;</span><br><span class="line">	return &amp;alphaReader&#123;reader: reader&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func alpha(r byte) byte &#123;</span><br><span class="line">	if (r &gt;= &apos;A&apos; &amp;&amp; r &lt;= &apos;Z&apos;) || (r &gt;= &apos;a&apos; &amp;&amp; r &lt;= &apos;z&apos;) &#123;</span><br><span class="line">		return r</span><br><span class="line">	&#125;</span><br><span class="line">	return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *alphaReader) Read(p []byte) (int, error) &#123;</span><br><span class="line">	n, err := a.reader.Read(p)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return n, err</span><br><span class="line">	&#125;</span><br><span class="line">	buf := make([]byte, n)</span><br><span class="line">	for i := 0; i &lt; n; i++ &#123;</span><br><span class="line">		if char := alpha(p[i]); char != 0 &#123;</span><br><span class="line">			buf[i] = char</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	copy(p, buf)</span><br><span class="line">	return n, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	// use an io.Reader as source for alphaReader</span><br><span class="line">	reader := newAlphaReader(strings.NewReader(&quot;Hello! It&apos;s 9am, where is the sun?&quot;))</span><br><span class="line">	p := make([]byte, 4)</span><br><span class="line">	for &#123;</span><br><span class="line">		n, err := reader.Read(p)</span><br><span class="line">		if err == io.EOF &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Print(string(p[:n]))</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与读取文件的io.Reader结合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	// use an os.File as source for alphaReader</span><br><span class="line">	file, err := os.Open(&quot;./alpha_reader3.go&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(1)</span><br><span class="line">	&#125;</span><br><span class="line">	defer file.Close()</span><br><span class="line">	</span><br><span class="line">	reader := newAlphaReader(file)</span><br><span class="line">	p := make([]byte, 4)</span><br><span class="line">	for &#123;</span><br><span class="line">		n, err := reader.Read(p)</span><br><span class="line">		if err == io.EOF &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Print(string(p[:n]))</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="io-Writer"><a href="#io-Writer" class="headerlink" title="io.Writer"></a>io.Writer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Writer interface &#123;</span><br><span class="line">    Write(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Write方法接受一个[]byte作为输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	proverbs := []string&#123;</span><br><span class="line">		&quot;Channels orchestrate mutexes serialize&quot;,</span><br><span class="line">		&quot;Cgo is not Go&quot;,</span><br><span class="line">		&quot;Errors are values&quot;,</span><br><span class="line">		&quot;Don&apos;t panic&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	var writer bytes.Buffer</span><br><span class="line"></span><br><span class="line">	for _, p := range proverbs &#123;</span><br><span class="line">		n, err := writer.Write([]byte(p))</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			os.Exit(1)</span><br><span class="line">		&#125;</span><br><span class="line">		if n != len(p) &#123;</span><br><span class="line">			fmt.Println(&quot;failed to write data&quot;)</span><br><span class="line">			os.Exit(1)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(writer.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现自定义io-Writer"><a href="#实现自定义io-Writer" class="headerlink" title="实现自定义io.Writer"></a>实现自定义io.Writer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">type chanWriter struct &#123;</span><br><span class="line">	ch chan byte</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func newChanWriter() *chanWriter &#123;</span><br><span class="line">	return &amp;chanWriter&#123;make(chan byte, 1024)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (w *chanWriter) Chan() &lt;-chan byte &#123;</span><br><span class="line">	return w.ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (w *chanWriter) Write(p []byte) (int, error) &#123;</span><br><span class="line">	n := 0</span><br><span class="line">	for _, b := range p &#123;</span><br><span class="line">		w.ch &lt;- b</span><br><span class="line">		n++</span><br><span class="line">	&#125;</span><br><span class="line">	return n, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (w *chanWriter) Close() error &#123;</span><br><span class="line">	close(w.ch)</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	writer := newChanWriter()</span><br><span class="line">	go func() &#123;</span><br><span class="line">		defer writer.Close()</span><br><span class="line">		writer.Write([]byte(&quot;Stream &quot;))</span><br><span class="line">		writer.Write([]byte(&quot;me!&quot;))</span><br><span class="line">	&#125;()</span><br><span class="line">	for c := range writer.Chan() &#123;</span><br><span class="line">		fmt.Printf(&quot;%c&quot;, c)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>chanWriter也实现了io.Closer, 调用writer.Close()关闭channel，避免chanWriter.Write<br>方法一直等待channel。</p>
<h3 id="os-File"><a href="#os-File" class="headerlink" title="os.File"></a>os.File</h3><p>亦实现了io.Writer和io.Reader接口，因此向文件写文件可以调用writer.Write([]byte), os.Create返回*os.File</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	proverbs := []string&#123;</span><br><span class="line">		&quot;Channels orchestrate mutexes serialize\n&quot;,</span><br><span class="line">		&quot;Cgo is not Go\n&quot;,</span><br><span class="line">		&quot;Errors are values\n&quot;,</span><br><span class="line">		&quot;Don&apos;t panic\n&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	// func Create(name string) (*File, error)</span><br><span class="line">	file, err := os.Create(&quot;./proverbs.txt&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(1)</span><br><span class="line">	&#125;</span><br><span class="line">	defer file.Close()</span><br><span class="line"></span><br><span class="line">	for _, p := range proverbs &#123;</span><br><span class="line">		n, err := file.Write([]byte(p))</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			os.Exit(1)</span><br><span class="line">		&#125;</span><br><span class="line">		if n != len(p) &#123;</span><br><span class="line">			fmt.Println(&quot;failed to write data&quot;)</span><br><span class="line">			os.Exit(1)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&quot;file write done&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>os.Open返回的*os.File是只读的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    // 如果需要读写文件，使用os.OpenFile</span><br><span class="line">    // 	file, err := os.OpenFile(&quot;./proverbs.txt&quot;, os.O_APPEND|os.O_CREATE|os.O_RDWR, 0644)</span><br><span class="line">	file, err := os.Open(&quot;./proverbs.txt&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(1)</span><br><span class="line">	&#125;</span><br><span class="line">	defer file.Close()</span><br><span class="line"></span><br><span class="line">	p := make([]byte, 4)</span><br><span class="line">	for &#123;</span><br><span class="line">		n, err := file.Read(p)</span><br><span class="line">		if err == io.EOF &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Print(string(p[:n]))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OpenFile可以用来打开一个已经存在的文件，也能创建并打开一个新文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 函数签名</span><br><span class="line">func OpenFile(name string, flag int, perm FileMode) (*File, error)</span><br><span class="line">// flag 用于指定文件的访问模式</span><br><span class="line">const (</span><br><span class="line">    O_RDONLY int = syscall.O_RDONLY // 只读模式打开文件</span><br><span class="line">    O_WRONLY int = syscall.O_WRONLY // 只写模式打开文件</span><br><span class="line">    O_RDWR   int = syscall.O_RDWR   // 读写模式打开文件</span><br><span class="line">    O_APPEND int = syscall.O_APPEND // 写操作时将数据附加到文件尾部</span><br><span class="line">    O_CREATE int = syscall.O_CREAT  // 如果不存在将创建一个新文件</span><br><span class="line">    O_EXCL   int = syscall.O_EXCL   // 和O_CREATE配合使用，文件必须不存在</span><br><span class="line">    O_SYNC   int = syscall.O_SYNC   // 打开文件用于同步I/O</span><br><span class="line">    O_TRUNC  int = syscall.O_TRUNC  // 如果可能，打开时清空文件</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>其中，O_RDONLY、O_WRONLY、O_RDWR 应该只指定一个，剩下的通过 | 操作符来指定。该函数内部会给 flags 加上 syscall.O_CLOEXEC，在 fork 子进程时会关闭通过 OpenFile 打开的文件，即子进程不会重用该文件描述符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 位掩码参数 perm 指定了文件的模式和权限位，类型是 os.FileMode，文件模式位常量定义在 os 中：</span><br><span class="line">const (</span><br><span class="line">    // 单字符是被 String 方法用于格式化的属性缩写。</span><br><span class="line">    ModeDir        FileMode = 1 &lt;&lt; (32 - 1 - iota) // d: 目录</span><br><span class="line">    ModeAppend                                     // a: 只能写入，且只能写入到末尾</span><br><span class="line">    ModeExclusive                                  // l: 用于执行</span><br><span class="line">    ModeTemporary                                  // T: 临时文件（非备份文件）</span><br><span class="line">    ModeSymlink                                    // L: 符号链接（不是快捷方式文件）</span><br><span class="line">    ModeDevice                                     // D: 设备</span><br><span class="line">    ModeNamedPipe                                  // p: 命名管道（FIFO）</span><br><span class="line">    ModeSocket                                     // S: Unix域socket</span><br><span class="line">    ModeSetuid                                     // u: 表示文件具有其创建者用户id权限</span><br><span class="line">    ModeSetgid                                     // g: 表示文件具有其创建者组id的权限</span><br><span class="line">    ModeCharDevice                                 // c: 字符设备，需已设置ModeDevice</span><br><span class="line">    ModeSticky                                     // t: 只有root/创建者能删除/移动文件</span><br><span class="line"></span><br><span class="line">    // 覆盖所有类型位（用于通过&amp;获取类型位），对普通文件，所有这些位都不应被设置</span><br><span class="line">    ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice</span><br><span class="line">    ModePerm FileMode = 0777 // 覆盖所有Unix权限位（用于通过&amp;获取类型位）</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="os-Stdout-os-Stdin-os-Stderr-其实也是-os-File"><a href="#os-Stdout-os-Stdin-os-Stderr-其实也是-os-File" class="headerlink" title="os.Stdout, os.Stdin, os.Stderr 其实也是*os.File"></a>os.Stdout, os.Stdin, os.Stderr 其实也是*os.File</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	proverbs := []string&#123;</span><br><span class="line">		&quot;Channels orchestrate mutexes serialize\n&quot;,</span><br><span class="line">		&quot;Cgo is not Go\n&quot;,</span><br><span class="line">		&quot;Errors are values\n&quot;,</span><br><span class="line">		&quot;Don&apos;t panic\n&quot;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for _, p := range proverbs &#123;</span><br><span class="line">		n, err := os.Stdout.Write([]byte(p))</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			os.Exit(1)</span><br><span class="line">		&#125;</span><br><span class="line">		if n != len(p) &#123;</span><br><span class="line">			fmt.Println(&quot;failed to write data&quot;)</span><br><span class="line">			os.Exit(1)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="io-Copy-方便的将流数据拷贝到目标reader"><a href="#io-Copy-方便的将流数据拷贝到目标reader" class="headerlink" title="io.Copy 方便的将流数据拷贝到目标reader"></a>io.Copy 方便的将流数据拷贝到目标reader</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	proverbs := new(bytes.Buffer)</span><br><span class="line">	proverbs.WriteString(&quot;Channels orchestrate mutexes serialize\n&quot;)</span><br><span class="line">	proverbs.WriteString(&quot;Cgo is not Go\n&quot;)</span><br><span class="line">	proverbs.WriteString(&quot;Errors are values\n&quot;)</span><br><span class="line">	proverbs.WriteString(&quot;Don&apos;t panic\n&quot;)</span><br><span class="line"></span><br><span class="line">	file, err := os.Create(&quot;./proverbs.txt&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(1)</span><br><span class="line">	&#125;</span><br><span class="line">	defer file.Close()</span><br><span class="line"></span><br><span class="line">	// copy from reader data into writer file</span><br><span class="line">	if _, err := io.Copy(file, proverbs); err != nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(1)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&quot;file created&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 或者</span><br><span class="line">func main() &#123;</span><br><span class="line">	file, err := os.Open(&quot;./proverbs.txt&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(1)</span><br><span class="line">	&#125;</span><br><span class="line">	defer file.Close()</span><br><span class="line"></span><br><span class="line">	if _, err := io.Copy(os.Stdout, file); err != nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(1)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="io-WriteString"><a href="#io-WriteString" class="headerlink" title="io.WriteString()"></a>io.WriteString()</h3><p>可以方便地将字符串写入到writer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	file, err := os.Create(&quot;./magic_msg.txt&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(1)</span><br><span class="line">	&#125;</span><br><span class="line">	defer file.Close()</span><br><span class="line">	if _, err := io.WriteString(file, &quot;Go is fun!&quot;); err != nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(1)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Pipe-writers-and-readers"><a href="#Pipe-writers-and-readers" class="headerlink" title="Pipe writers and readers"></a>Pipe writers and readers</h4><p>输入io.PipeWriter和io.PipeReader模型IO操作，如在内存管道中。数据被写入管道的写入端，并使用单独的GO例程在管道的读取器端读取数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	proverbs := new(bytes.Buffer)</span><br><span class="line">	proverbs.WriteString(&quot;Channels orchestrate mutexes serialize\n&quot;)</span><br><span class="line">	proverbs.WriteString(&quot;Cgo is not Go\n&quot;)</span><br><span class="line">	proverbs.WriteString(&quot;Errors are values\n&quot;)</span><br><span class="line">	proverbs.WriteString(&quot;Don&apos;t panic\n&quot;)</span><br><span class="line"></span><br><span class="line">	piper, pipew := io.Pipe()</span><br><span class="line"></span><br><span class="line">	// write in writer end of pipe</span><br><span class="line">	go func() &#123;</span><br><span class="line">		defer pipew.Close()</span><br><span class="line">		io.Copy(pipew, proverbs)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	// read from reader end of pipe.</span><br><span class="line">	io.Copy(os.Stdout, piper)</span><br><span class="line">	piper.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Buffered-IO"><a href="#Buffered-IO" class="headerlink" title="Buffered IO"></a>Buffered IO</h4><p>GO通过包bufio支持缓冲IO，这使得使用文本内容更加容易。例如，下面的程序读取以值‘\n’分隔的逐行文件的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	file, err := os.Open(&quot;./planets.txt&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(1)</span><br><span class="line">	&#125;</span><br><span class="line">	defer file.Close()</span><br><span class="line">	reader := bufio.NewReader(file)</span><br><span class="line"></span><br><span class="line">	for &#123;</span><br><span class="line">		line, err := reader.ReadString(&apos;\n&apos;)</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			if err == io.EOF &#123;</span><br><span class="line">				break</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				fmt.Println(err)</span><br><span class="line">				os.Exit(1)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Print(line)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Util-package"><a href="#Util-package" class="headerlink" title="Util package"></a>Util package</h4><p>包ioutil是io的一个子包，它为IO提供了一些方便的功能。例如，以下代码使用函数ReadFile将文件的内容加载到[]byte中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  &quot;io/ioutil&quot;</span><br><span class="line">   ...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	bytes, err := ioutil.ReadFile(&quot;./planets.txt&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(1)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(&quot;%s&quot;, bytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="还有其他IO-Stream-操作"><a href="#还有其他IO-Stream-操作" class="headerlink" title="还有其他IO Stream 操作"></a>还有其他IO Stream 操作</h3><ul>
<li>file IO</li>
<li>buffered IO</li>
<li>network IO</li>
<li>formatted IO</li>
</ul>
</details>


<h2 id="os-exec-执行外部命令"><a href="#os-exec-执行外部命令" class="headerlink" title="os/exec 执行外部命令"></a>os/exec 执行外部命令</h2><blockquote>
<p><a href="https://blog.kowalczyk.info/article/wOYk/advanced-command-execution-in-go-with-osexec.html" target="_blank" rel="noopener">Advanced command execution in Go with os/exec</a></p>
</blockquote>
<details><summary>详情</summary>
简单的例子
<pre>
package main

<p>// <a href="https://blog.kowalczyk.info/article/wOYk/advanced-command-execution-in-go-with-osexec.html" target="_blank" rel="noopener">https://blog.kowalczyk.info/article/wOYk/advanced-command-execution-in-go-with-osexec.html</a><br>// to run:<br>// go run 01-simple-exec-v3.go</p>
<p>import (<br>    “log”<br>    “os”<br>    “os/exec”<br>    “runtime”<br>)</p>
<p>func main() {<br>    cmd := exec.Command(“ls”, “-lah”)<br>    if runtime.GOOS == “windows” {<br>        cmd = exec.Command(“tasklist”)<br>    }<br>    cmd.Stdout = os.Stdout<br>    cmd.Stderr = os.Stderr<br>    err := cmd.Run()<br>    if err != nil {<br>        log.Fatalf(“cmd.Run() failed with %s\n”, err)<br>    }<br>}<br></p></pre><p></p>
<ul>
<li><p>重定向命令行输出到os.stdout, os.stderr</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmd := exec.Command(&quot;ls&quot;, &quot;-lah&quot;)</span><br><span class="line">cmd.Stdout = os.Stdout</span><br><span class="line">cmd.Stderr = os.Stderr</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取命令行输出 CombineOutput()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">out, err:= CombineOutput()</span><br><span class="line">// out 为 []byte</span><br><span class="line">fmt.Println(&quot;combined out:\n%s\n&quot;, string(out))</span><br></pre></td></tr></table></figure>
</li>
<li><p>分离命令行输出stderr, stdout</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stdoutIn, err := cmd.StdoutPipe()</span><br><span class="line">stderrIn, err := cmd.StderrPipe()</span><br></pre></td></tr></table></figure>
</li>
<li><p>exec库也可以获取/设置环境变量输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">additionalEnv := &quot;FOO=bar&quot;</span><br><span class="line">// os.Environ() 返回一个[]string, 其元素格式为&quot;FOO=bar&quot;, FOO为环境变量名，bar为值</span><br><span class="line">newEnv := append(os.Environ(), additionalEnv))</span><br><span class="line">cmd.Env = newEnv</span><br><span class="line">// 获取环境变量</span><br><span class="line">path, err := exec.LookPath(&quot;ls&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;didn&apos;t find &apos;ls&apos; executable\n&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    fmt.Printf(&quot;&apos;ls&apos; executable is in &apos;%s&apos;\n&quot;, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</details>


<h3 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h3><details>

<ul>
<li><a href="https://www.calhoun.io/using-named-return-variables-to-capture-panics-in-go/" target="_blank" rel="noopener">返回一个命名的异常的好处</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func pressButton() &#123;</span><br><span class="line">  fmt.Println(&quot;I&apos;m Mr. Meeseeks, look at me!!&quot;)</span><br><span class="line">  // other stuff then happens, but if Jerry asks to</span><br><span class="line">  // remove 2 strokes from his golf game...</span><br><span class="line">  panic(&quot;It&apos;s gettin&apos; weird!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func doStuff() error &#123;</span><br><span class="line">  var err error</span><br><span class="line">  // If there is a panic we need to recover in a deferred func</span><br><span class="line">  defer func() &#123;</span><br><span class="line">    if r := recover(); r != nil &#123;</span><br><span class="line">      err = errors.New(&quot;the meeseeks went crazy!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  pressButton()</span><br><span class="line">  return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>分析: 上面的代码在pressButton()时触发了panic，导致return err这行代码是执行不到的，尽管在deferred func中我们对err重新赋值，但return 的并不是我们在var err error定义的，应该是go runtime引擎定义的err默认值nil。<br><strong>函数返回值有命名时，defer修改的err就能作为return的结果了</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func doStuff() (err error) &#123;</span><br><span class="line">	// If there is a panic we need to recover in a deferred func</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		if r := recover(); r != nil &#123;</span><br><span class="line">			err = errors.New(&quot;the meeseeks went crazy!&quot;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	pressButton()</span><br><span class="line">	return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><blockquote>
<p><a href="https://blog.learngoprogramming.com/gotchas-of-defer-in-go-1-8d070894cb01" target="_blank" rel="noopener">https://blog.learngoprogramming.com/gotchas-of-defer-in-go-1-8d070894cb01</a><br><a href="https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa" target="_blank" rel="noopener">https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa</a></p>
</blockquote>
<details>

<h3 id="先来一道菜"><a href="#先来一道菜" class="headerlink" title="先来一道菜"></a>先来一道菜</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">var println = fmt.Println</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">	println(DeferFunc1(1))</span><br><span class="line">	println(DeferFunc2(1))</span><br><span class="line">	println(DeferFunc3(1))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func DeferFunc1(i int) (t int) &#123;</span><br><span class="line">	t = i</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		t += 3</span><br><span class="line">	&#125;()</span><br><span class="line">	return t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func DeferFunc2(i int) int &#123;</span><br><span class="line">	t := i</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		t += 3</span><br><span class="line">	&#125;()</span><br><span class="line">	return t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func DeferFunc3(i int) (t int) &#123;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		t += i</span><br><span class="line">	&#125;()</span><br><span class="line">	return 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在循环中使用defer。<strong>只有循环结束后，defer函数才执行</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">  for i:=0; i &lt;= 10; i++ &#123;</span><br><span class="line">    fmt.Println(&quot;loop &quot;, i)</span><br><span class="line">    defer func() &#123;</span><br><span class="line">      fmt.Println(&quot;defer loop&quot;, i)</span><br><span class="line">    &#125;() // defer 函数只会看到最近的值，至此i为运行后的11</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 结果</span><br><span class="line">loop  0</span><br><span class="line">loop  1</span><br><span class="line">loop  2</span><br><span class="line">loop  3</span><br><span class="line">loop  4</span><br><span class="line">loop  5</span><br><span class="line">loop  6</span><br><span class="line">loop  7</span><br><span class="line">loop  8</span><br><span class="line">loop  9</span><br><span class="line">loop  10</span><br><span class="line">defer loop 11</span><br><span class="line">defer loop 11</span><br><span class="line">defer loop 11</span><br><span class="line">defer loop 11</span><br><span class="line">defer loop 11</span><br><span class="line">defer loop 11</span><br><span class="line">defer loop 11</span><br><span class="line">defer loop 11</span><br><span class="line">defer loop 11</span><br><span class="line">defer loop 11</span><br><span class="line">defer loop 11</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如果修改下defer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">defer fmt.Println(&quot;defer loop&quot;, i) // 将参数传到函数</span><br><span class="line">//结果为</span><br><span class="line">defer loop 10</span><br><span class="line">defer loop 9</span><br><span class="line">defer loop 8</span><br><span class="line">defer loop 7</span><br><span class="line">defer loop 6</span><br><span class="line">defer loop 5</span><br><span class="line">defer loop 4</span><br><span class="line">defer loop 3</span><br><span class="line">defer loop 2</span><br><span class="line">defer loop 1</span><br><span class="line">defer loop 0</span><br></pre></td></tr></table></figure>

<p>图解<br><img src="http://ww1.sinaimg.cn/large/9d799d25ly1g1uaoiqgjkj20wm0j9wgr.jpg" alt></p>
<ul>
<li><p>defer函数在声明它的函数执行后才被执行</p>
<blockquote>
<p>defer belongs to a func not to a block.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">  func() &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">      fmt.Println(&quot;func: defer runs&quot;)</span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(&quot;func: ends&quot;)</span><br><span class="line">  &#125;()</span><br><span class="line">  fmt.Println(&quot;main: ends&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>deferred method， 一句话，defer会copy一份method函数的receiver，只有指针reiceiver的方法在copy后依然能指向同一内存地址。</p>
</li>
</ul>
<ol>
<li>value receiver<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Car struct &#123;</span><br><span class="line">  model string</span><br><span class="line">&#125;</span><br><span class="line">func (c Car) PrintModel() &#123;</span><br><span class="line">  fmt.Println(c.model)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">  c := Car&#123;model: &quot;DeLorean DMC-12&quot;&#125;</span><br><span class="line">  defer c.PrintModel()</span><br><span class="line">  c.model = &quot;Chevrolet Impala&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>输出为：<br>DeLorean DMC-12</p>
<ol start="2">
<li>pointer receiver<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (c *Car) PrintModel() &#123;</span><br><span class="line">  fmt.Println(c.model)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>输出：Chevrolet Impala</p>
<ol start="3">
<li>小改动上面，会有很大不同<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">type Car struct &#123;</span><br><span class="line">  model string</span><br><span class="line">&#125;</span><br><span class="line">func (c *Car) PrintModel() string &#123;</span><br><span class="line">  return c.model</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">  c := Car&#123;model: &quot;DeLorean DMC-12&quot;&#125;</span><br><span class="line">  defer fmt.Println(c.PrintModel())</span><br><span class="line">  c.model = &quot;Chevrolet Impala&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>输出为DeLorean DMC-12<br>因为c.PrintModel()已经被计算后，而fmt.Println才是被defer延时执行的。</p>
</details>    

<h2 id="const"><a href="#const" class="headerlink" title="const"></a><a href="https://blog.learngoprogramming.com/learn-golang-typed-untyped-constants-70b4df443b61" target="_blank" rel="noopener">const</a></h2><ul>
<li>定义常数时，可以不指定该类型，由赋值自动推导，当赋值为数值时，不指定类型的常量可以保存该数值的位数</li>
</ul>
<details>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	// ------------------------------------------------</span><br><span class="line">	// LOSS OF PRECISION</span><br><span class="line">	// ------------------------------------------------</span><br><span class="line">    </span><br><span class="line">	// const Pi lives in the ideal numbers universe which has at least 256-bit high-precision</span><br><span class="line">	const Pi = 3.14159265358979323846264338327950288419716939937510582097494459</span><br><span class="line"></span><br><span class="line">	// when evaluated, it&apos;ll be converted into a float64</span><br><span class="line">	fmt.Printf(&quot;Pi            : %.50g\n&quot;, Pi)</span><br><span class="line">	</span><br><span class="line">	// ------------------------------------------------</span><br><span class="line">	// HIGH AND LOW PRECISION DIFFERENCE</span><br><span class="line">	// ------------------------------------------------</span><br><span class="line"></span><br><span class="line">	const uta, utb = 0.116, 45.0         // untyped constants</span><br><span class="line">	const ta, tb float64 = uta, utb      // typed constants</span><br><span class="line">    </span><br><span class="line">	highPrecision := uta * utb</span><br><span class="line">	lowPrecision := ta * tb</span><br><span class="line"></span><br><span class="line">	// high precision calculation - untyped constants - ideal numbers space</span><br><span class="line">	fmt.Printf(&quot;high-precision: %.50f\n&quot;, highPrecision)</span><br><span class="line"></span><br><span class="line">	// low precision calculation - typed constants</span><br><span class="line">	fmt.Printf(&quot;low precision : %.50f\n&quot;, lowPrecision)</span><br><span class="line">    </span><br><span class="line">	fmt.Printf(&quot;difference    : %.50f\n&quot;, highPrecision - lowPrecision)</span><br><span class="line">&#125;</span><br><span class="line">// 输出为：</span><br><span class="line">Pi            : 3.141592653589793115997963468544185161590576171875</span><br><span class="line">high-precision: 5.21999999999999975131004248396493494510650634765625</span><br><span class="line">low precision : 5.22000000000000063948846218409016728401184082031250</span><br><span class="line">difference    : -0.00000000000000088817841970012523233890533447265625</span><br></pre></td></tr></table></figure>

</details>

<ul>
<li>常量定义后，可以在另外一个作用域重新声明，但是会覆盖掉原来的</li>
</ul>
<h3 id="init函数详解"><a href="#init函数详解" class="headerlink" title="init函数详解"></a><a href="https://studygolang.com/articles/13865?fr=sidebar" target="_blank" rel="noopener">init函数详解</a></h3><ul>
<li>初始化导入的包（递归的定义）</li>
<li>在包级别为声明的变量计算并分配初始值</li>
<li>执行包内的 init 函数（下面的空白标识符就是一个例子）<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import _ &quot;image/png&quot;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>init函数不需要函数，也不返回任何值。与main类似，因为标识符init没有被声明也就不能被引用：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">    fmt.Println(&quot;init&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    init()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="导入顺序"><a href="#导入顺序" class="headerlink" title="导入顺序"></a>导入顺序</h3><p>处于同一层目录的<em>.go文件或者或同一个package内的</em>.go, 可以定义各自的init函数，而且支持定义多次init函数，如由文件a.go, b.go, main.go, z.go，其中a.go</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func init() &#123;</span><br><span class="line">  fmt.Println(&quot;a.go: 1st init&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func init() &#123;</span><br><span class="line">  fmt.Println(&quot;a.go: 2nd init&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var _ int = a()</span><br><span class="line">func a() int &#123;</span><br><span class="line">  fmt.Println(&quot;a.go: call a()&quot;)</span><br><span class="line">  return 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.go</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func init() &#123;</span><br><span class="line">  fmt.Println(&quot;main.go: 1st init&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func init() &#123;</span><br><span class="line">  fmt.Println(&quot;main.go: 2nd init&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var _ int = m()</span><br><span class="line">func m() int &#123;</span><br><span class="line">  fmt.Println(&quot;main.go: call m()&quot;)</span><br><span class="line">  return 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  fmt.Println(&quot;main.go: call in main()&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b.go和z.go与a.go内容差不多，将相关内容替换成b和z即可。运行main.go结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">go version go1.12 linux/amd64</span><br><span class="line">a.go: call a()</span><br><span class="line">b.go: call b()</span><br><span class="line">main.go: call m()</span><br><span class="line">z.go: call z()</span><br><span class="line">a.go: 1st init</span><br><span class="line">a.go: 2nd init</span><br><span class="line">b.go: 1st init</span><br><span class="line">b.go: 2nd init</span><br><span class="line">main.go: 1st init</span><br><span class="line">main.go: 2nd init</span><br><span class="line">z.go: 1st init</span><br><span class="line">z.go: 2nd init</span><br><span class="line">main.go: call in main()</span><br></pre></td></tr></table></figure>

<p>执行顺序为大概安装以下顺序：</p>
<ul>
<li>声明语句先于init函数执行</li>
<li>多个init函数安装定义顺序执行</li>
<li>上面的执行步骤按照文件名首字母的的顺序依次执行<h2 id="for…range…"><a href="#for…range…" class="headerlink" title="for…range…"></a>for…range…</h2><blockquote>
<p>在Go的for…range循环中，Go始终使用值拷贝的方式代替被遍历的元素本身，简单来说，就是for…range中那个value，是一个值拷贝，而不是元素本身。这样一来，当我们期望用&amp;获取元素的地址时，实际上只是取到了value这个临时变量的地址，而非list中真正被遍历到的某个元素的地址。而在整个for…range循环中，value这个临时变量会被重复使用<br>具体可看<a href="https://blog.csdn.net/xingwangc2014/article/details/79777724" target="_blank" rel="noopener">for …range 的各种踩坑</a></p>
</blockquote>
</li>
</ul>
<ol>
<li><p>range的元素是指针</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pase_student</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*student)</span><br><span class="line">    stus := []student&#123;</span><br><span class="line">        &#123;Name: <span class="string">"zhou"</span>,Age: <span class="number">24</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">"li"</span>,Age: <span class="number">23</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">"wang"</span>,Age: <span class="number">22</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,stu := <span class="keyword">range</span> stus &#123;</span><br><span class="line">        <span class="comment">// 遍历结束后m中所有元素都是stu指针，自然都指向stus最后的一个元素</span></span><br><span class="line">        m[stu.Name] =&amp;stu</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">m中的每个元素都是遍历的最后一个<span class="keyword">struct</span>的值拷贝。</span><br><span class="line"><span class="comment">// 因此像下面这样想改动原切片元素的方式也是不行的</span></span><br><span class="line"><span class="keyword">for</span> _, stu := <span class="keyword">range</span> stus &#123;</span><br><span class="line">    stu.Age = stu.Age+<span class="number">10</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(stus);i++ &#123;</span><br><span class="line">   m[stus[i].Name] = &amp;stus[i]</span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">for</span> k,v:=<span class="keyword">range</span> m &#123;        </span><br><span class="line">   <span class="built_in">println</span>(k,<span class="string">"=&gt;"</span>,v.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> stus &#123;</span><br><span class="line">	stu:=stus[i]</span><br><span class="line">	m[stu.Name] = &amp;stu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>range副本机制, for k, v := range somethig; v只是一个值拷贝，并且会多次重复使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">// 47.执行下面代码输出什么？</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    five := []string&#123;&quot;Annie&quot;, &quot;Betty&quot;, &quot;Charley&quot;, &quot;Doug&quot;, &quot;Edward&quot;&#125;</span><br><span class="line"></span><br><span class="line">    for _, v := range five &#123;</span><br><span class="line">        five = five[:2]</span><br><span class="line">        fmt.Printf(&quot;v[%s]\n&quot;, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当迭代对象为map时，在range迭代中删除和新增元素，会有不同的表现        </p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 对map新增，每次迭代的结果都不一样</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    m := map[int]int&#123;&apos;A&apos;:65&#125;</span><br><span class="line">    for k, v := range m &#123;</span><br><span class="line">        </span><br><span class="line">        m[k + 1] = v + 1</span><br><span class="line">        fmt.Printf(&quot;Map Range: m[%s]=%d\n&quot;, string(k), v)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">// 结果1</span><br><span class="line">Map Range: m[A]=65</span><br><span class="line">Map Range: m[B]=66</span><br><span class="line">Map Range: m[C]=67</span><br><span class="line">Map Range: m[D]=68</span><br><span class="line">Map Range: m[E]=69</span><br><span class="line">Map Range: m[F]=70</span><br><span class="line">Map Range: m[G]=71</span><br><span class="line">// 结果2</span><br><span class="line">Map Range: m[A]=65</span><br><span class="line">Map Range: m[B]=66</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 删除掉后面一个元素，它不会被迭代到</span><br><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    m := map[int]int&#123;&apos;A&apos;:65, &apos;B&apos;:66, &apos;C&apos;:67, &apos;D&apos;: 68&#125;</span><br><span class="line">    for k, v := range m &#123;</span><br><span class="line">        </span><br><span class="line">        delete(m, &apos;C&apos;)</span><br><span class="line">        fmt.Printf(&quot;Map Range: m[%s]=%d\n&quot;, string(k), v)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">// 结果</span><br><span class="line">Map Range: m[A]=65</span><br><span class="line">Map Range: m[B]=66</span><br><span class="line">Map Range: m[D]=68</span><br></pre></td></tr></table></figure>

<h2 id="make-new的区别"><a href="#make-new的区别" class="headerlink" title="make, new的区别"></a><a href="https://www.flysnow.org/2017/10/23/go-new-vs-make.html" target="_blank" rel="noopener">make, new的区别</a></h2><blockquote>
<p>new和make是内建的两个函数，主要用来创建分配类型内存</p>
</blockquote>
<details>

<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var i *int</span><br><span class="line">*i = 10</span><br></pre></td></tr></table></figure>

<p>上诉代码会报错：panic: runtime error: invalid memory address or nil pointer dereference<br>这时new函数就派上用场了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var i = new(int) </span><br><span class="line">*i = 10</span><br></pre></td></tr></table></figure>

<p>new接受一个类型作为输入，并返回一个指向该类型的指针,并且初始化该类型的值为该类型对应的零值，如int对应0，interface{}对应nil</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// The new built-in function allocates memory. The first argument is a type,</span><br><span class="line">// not a value, and the value returned is a pointer to a newly</span><br><span class="line">// allocated zero value of that type.</span><br><span class="line">func new(Type) *Type</span><br></pre></td></tr></table></figure>

<h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>make只用于chan, map以及切片的内存创建，并且直接返回该类型，而不是该类型的指针，因为这三种类型就是引用类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func make(t Type, size ...IntegerType) Type</span><br></pre></td></tr></table></figure>

<h3 id="make初始化后不是零值nil"><a href="#make初始化后不是零值nil" class="headerlink" title="make初始化后不是零值nil"></a>make初始化后不是零值nil</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mslice := make([]int, 5)</span><br><span class="line">mmap := make(map[string]int)</span><br><span class="line">mchan := make(chan int)</span><br><span class="line">mchan1 := make(chan struct&#123;&#125;)</span><br><span class="line">对应的结果：</span><br><span class="line">[0 0 0 0 0]</span><br><span class="line">map[]</span><br><span class="line">0xc42006a060</span><br><span class="line">0xc42006a0c0</span><br></pre></td></tr></table></figure>

</details>


<h2 id="类型断言-type-assertion"><a href="#类型断言-type-assertion" class="headerlink" title="类型断言 type assertion"></a>类型断言 type assertion</h2><ul>
<li><a href="https://studygolang.com/articles/5093" target="_blank" rel="noopener">Go-类型断言</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type MyInt int</span><br><span class="line">var i int= 1</span><br><span class="line">var jMyInt = interface&#123;&#125;(i).(MyInt)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>需要转换为interface类型才能进行类型断言</p>
<ul>
<li>类型断言的第二个参数。提供第二个参数来判断断言是否成功。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a interface&#123;&#125;</span><br><span class="line">a = 1</span><br><span class="line">aInt := a.(int) // ?</span><br><span class="line"></span><br><span class="line">a = &quot;Atlanta&quot;</span><br><span class="line">aInt = a.(int) // Runtime panic!</span><br><span class="line">aInt, ok := a.(int) // ok will be false and no panic</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="init和main函数"><a href="#init和main函数" class="headerlink" title="init和main函数"></a>init和main函数</h2><ol>
<li><a href="https://studygolang.com/articles/3873" target="_blank" rel="noopener">https://studygolang.com/articles/3873</a></li>
</ol>
<h2 id="变量自增-自减"><a href="#变量自增-自减" class="headerlink" title="变量自增/自减"></a>变量自增/自减</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//正确 </span><br><span class="line">var i = 1</span><br><span class="line">i++</span><br><span class="line">i--</span><br><span class="line">// 不存在 ++i, --i, 同时i++不能在赋值表达语句中出现</span><br><span class="line">// 如 j = i++</span><br></pre></td></tr></table></figure>

<h2 id="获取包含中文的字符串的的字符数"><a href="#获取包含中文的字符串的的字符数" class="headerlink" title="获取包含中文的字符串的的字符数"></a>获取包含中文的字符串的的字符数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &quot;unicode/utf8&quot;</span><br><span class="line"></span><br><span class="line">s := &quot;Hello, 世界&quot;</span><br><span class="line">fmt.Println(len(s))                    // &quot;13&quot;</span><br><span class="line">fmt.Println(utf8.RuneCountInString(s)) // &quot;9&quot;</span><br><span class="line"></span><br><span class="line">\\ 遍历含有中文的字符串</span><br><span class="line">for i := 0; i &lt; len(s); &#123;</span><br><span class="line">    r, size := utf8.DecodeRuneInString(s[i:])</span><br><span class="line">    fmt.Printf(&quot;%d\t%c\n&quot;, i, r)</span><br><span class="line">    i += size</span><br><span class="line">&#125;</span><br><span class="line">\\ range遍历</span><br><span class="line">for i, r := range &quot;Hello, 世界&quot; &#123;</span><br><span class="line">    fmt.Printf(&quot;%d\t%q\t%d\n&quot;, i, r, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><blockquote>
<p><a href="http://www.golangprograms.com/golang/string-functions/" target="_blank" rel="noopener">Most Popular Golang String Functions
</a><br><a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter02/02.1.html" target="_blank" rel="noopener">strings 字符串操作</a></p>
</blockquote>
<ul>
<li>字符串转换</li>
</ul>
<ol>
<li>字符串转换成数字<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;strconv&quot;</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">var x int64 = 1</span><br><span class="line">func main() &#123;</span><br><span class="line">  x := 123</span><br><span class="line">  y := fmt.Sprintf(&quot;%d&quot;, x)</span><br><span class="line">  fmt.Println(y, strconv.Itoa(x))</span><br><span class="line">  x_str := &quot;123&quot;</span><br><span class="line">  x_int, _ := strconv.Atoi(x_str)</span><br><span class="line">  fmt.Println(x_int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>字符串排序</li>
</ul>
<ol>
<li><a href="https://www.jianshu.com/p/6e52bad56e06" target="_blank" rel="noopener">golang: 使用 sort 来排序</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">  &quot;sort&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  var names = []string&#123;&quot;orange&quot;, &quot;apple&quot;, &quot;zebera&quot;, &quot;tony&quot;&#125;</span><br><span class="line">  sort.Sort(sort.StringSlice(names))</span><br><span class="line">  fmt.Println(names)</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>传给sort.Sort的类型需要以下接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Interface interface &#123; </span><br><span class="line"> // Len is the number of elements in the collection.</span><br><span class="line"> Len() int</span><br><span class="line"> // Less reports whether the element with</span><br><span class="line"> // index i should sort before the element with index j.</span><br><span class="line"> Less(i, j int) bool</span><br><span class="line"> // Swap swaps the elements with indexes i and j.</span><br><span class="line"> Swap(i, j int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但sort.StringSlice, sort.IntSlice可以直接使用</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li><p>空接口 interface{}，可以赋值为任意值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var any interface&#123;&#125;</span><br><span class="line">any = true</span><br><span class="line">any = 12.34</span><br><span class="line">any = &quot;hello&quot;</span><br><span class="line">any = map[stirng]int&#123;&quot;one&quot;:1&#125;</span><br><span class="line">any = new&#123;bytes.Buffer&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获得变量实现的接口类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var w io.Writer</span><br><span class="line">fmt.Printf(&quot;%T\n&quot;, w) // &quot;&lt;nil&gt;&quot;</span><br><span class="line">w = os.Stdout</span><br><span class="line">fmt.Printf(&quot;%T\n&quot;, w) // &quot;*os.File&quot;</span><br><span class="line">w = new(bytes.Buffer)</span><br><span class="line">fmt.Printf(&quot;%T\n&quot;, w) // &quot;*bytes.Buffer&quot;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><ul>
<li>如果在select语句中发现某个通道已关闭，那么应该怎么屏蔽掉它所在的分支？<blockquote>
<p>当第二个boolean参数为false的时候，在相应的case中设置chan为nil零值，再次case求值的时候会遭遇阻塞，会屏蔽该case。</p>
</blockquote>
</li>
</ul>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><ol>
<li><a href="https://www.golangtc.com/t/575442b8b09ecc02f7000057" target="_blank" rel="noopener">什么是空结构体？</a><blockquote>
<p>空结构体 struct{}{}, 不占用内存空间。如果通道需要一个触发信息，可以向通道传送struct{}{}</p>
</blockquote>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.ticktockit.com/2019/08/19/golang01/" data-id="cjzh68dag0001mcvrkvxnmwav" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/08/19/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/19/golang01/">golang技巧集锦</a>
          </li>
        
          <li>
            <a href="/2019/08/19/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 TickTockit<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>